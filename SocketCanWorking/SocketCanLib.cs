using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using Communications.Can;
using SocketCanWorking.Exceptions;

namespace SocketCanWorking
{
    /// <summary>Оболочка над функциями, экспортируемыми из SocketCan.</summary>
    public static unsafe class SocketCanLib
    {
        /// <summary>Флаги CanFd фрейма.</summary>
        [Flags]
        private enum CanFdFlags : byte
        {
            /// <summary>Bit rate switch (second bitrate for payload data).</summary>
            CanFdBrs = 0x01,

            /// <summary>Error state indicator of the transmitting node.</summary>
            CanFdEsi = 0x02
        }

        /// <summary>Структура передачи CAN-кадра из SocketCan библиотеки.</summary>
        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        private struct FrameBag
        {
            /// <summary>Сообщение.</summary>
            public readonly SocketCanFdFrame Frame;

            /// <summary>Время принятия сообщения.</summary>
            public readonly TimeVal ReceiveTime;

            /// <summary>Флаги принятого сообщения.</summary>
            public readonly FrameBagFlags Flags;

            public override string ToString() { return string.Format("ReceiveTime: {1}, Flags: {2}, Frame: ({0})", Frame, ReceiveTime, Flags); }
        }

        /// <summary>Флаги в структуре передачи CAN-кадра из SocketCan библиотеки.</summary>
        [Flags]
        private enum FrameBagFlags : byte
        {
            /// <summary>Показывает, что пакет является Loopback-пакетом.</summary>
            /// <remarks>Loopback-пакеты в SocketCan используются для подтверждения отправки сообщения.</remarks>
            Loopback = 0x01
        }

        /// <summary>Структура CAN-фрейма в формате SocketCanFd.</summary>
        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        private struct SocketCanFdFrame
        {
            /// <remarks>
            ///     <list type="table">
            ///         <item>
            ///             <term>Bit.</term>
            ///             <description>Description.</description>
            ///         </item>
            ///         <item>
            ///             <term>0-28.</term>
            ///             <description> Identifier (11/29 bit).</description>
            ///         </item>
            ///         <item>
            ///             <term>29.</term>
            ///             <description>Error frame flag (0 = data frame, 1 = error frame).</description>
            ///         </item>
            ///         <item>
            ///             <term>30.</term>
            ///             <description>Remote transmission request flag (1 = rtr frame).</description>
            ///         </item>
            ///         <item>
            ///             <term>31.</term>
            ///             <description>Frame format flag (0 = standart 11 bit, 1 = extended 29 bit).</description>
            ///         </item>
            ///     </list>
            /// </remarks>
            public readonly UInt32 Id;

            public readonly Byte DataLength;

            /// <remarks>
            ///     <para>
            ///         The use of struct canfd_frame implies the Extended Data Length (EDL) bit to be set in the CAN frame bitstream
            ///         on the wire. The EDL bit switch turns the CAN controllers bitstream processor into the CAN FD mode which
            ///         creates two new options within the CAN FD frame specification:
            ///     </para>
            ///     <para>
            ///         Bit Rate Switch - to indicate a second bitrate is/was used for the payload Error State Indicator - represents
            ///         the error state of the transmitting node.
            ///     </para>
            ///     <para>
            ///         As the CANFD_ESI bit is internally generated by the transmitting CAN controller only the CANFD_BRS bit is
            ///         relevant for real CAN controllers when building a CAN FD frame for transmission. Setting the CANFD_ESI bit can
            ///         make sense for virtual CAN interfaces to test applications with echoed frames.
            ///     </para>
            /// </remarks>
            public readonly CanFdFlags Flags;

            public readonly Byte Reserved0;
            public readonly Byte Reserved1;
            public fixed byte Data [8];

            public SocketCanFdFrame(uint Id, byte[] Data)
                : this()
            {
                this.Id = Id;
                DataLength = (Byte)Data.Length;
                fixed (byte* d = this.Data)
                {
                    for (int i = 0; i < Data.Length; i++)
                        d[i] = Data[i];
                }
            }

            public SocketCanFdFrame(CanFrame Frame) : this((uint)Frame.Id, Frame.Data) { }

            public override string ToString() { return string.Format("Id: {0:X3}, DataLength: {1}, Flags: {2}", Id, DataLength, Flags); }
        }

        /// <summary>Сишная структура TimeVal.</summary>
        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        private struct TimeVal
        {
            private static readonly DateTime Epoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);

            public TimeVal(uint UnixTime, uint Microseconds)
            {
                this.UnixTime = UnixTime;
                this.Microseconds = Microseconds;
            }

            /// <summary>Время приёма сообщения с точностью до секунды (в формате UNIX Time).</summary>
            public readonly UInt32 UnixTime;

            /// <summary>Время приёма сообщения в микросекундах с начала текущей секунды.</summary>
            public readonly UInt32 Microseconds;

            public static implicit operator DateTime(TimeVal tv) { return Epoch.AddSeconds(tv.UnixTime).AddMilliseconds((Double)tv.Microseconds / 1000); }

            public override string ToString() { return string.Format("{0}.{1:000000}s", UnixTime, Microseconds); }
        }

        #region Импорт функций из библиотеки

        /// <summary>Имя библиотеки-связки с SocketCan.</summary>
        public const string SocketCanLibraryName = "libSocketCanLib.so.1";

        /// <summary>Открывает сокет.</summary>
        /// <param name="InterfaceName">Имя сокета в виде c-строки.</param>
        /// <returns>Номер открытого сокета.</returns>
        [DllImport(SocketCanLibraryName, CallingConvention = CallingConvention.Cdecl)]
        private static extern int SocketOpen(byte[] InterfaceName);

        /// <summary>Закрывает сокет.</summary>
        /// <param name="Number">Номер сокета.</param>
        /// <returns>Антон придумает.</returns>
        [DllImport(SocketCanLibraryName, CallingConvention = CallingConvention.Cdecl)]
        private static extern int SocketClose(int Number);

        /// <summary>Отправляет в сокет.</summary>
        /// <param name="Number">Номер сокета.</param>
        /// <param name="Frame">Фрейм для отправки.</param>
        /// <returns>True, если фрейм успешно отправлен.</returns>
        [DllImport(SocketCanLibraryName, CallingConvention = CallingConvention.Cdecl)]
        private static extern int SocketWrite(int Number, SocketCanFdFrame* Frame);

        /// <summary>Читает сообщения из входящего буфера сокета.</summary>
        /// <param name="Number">Номер сокета.</param>
        /// <param name="Bags">Указатель на место, в которое будут помещены прочитанные сообщения.</param>
        /// <param name="BagsCount">Количество принимаемых сообщений.</param>
        /// <param name="Timeout">Таймаут ожидания сообщений в милисекундах (0 - до конца времён).</param>
        /// <remarks>При отсутствии сообщений в буфере блокируется до появления первого сообщения или истечения
        ///     <paramref name="Timeout" />. При наличии сообщений читает их и записывает в <paramref name="Bags" />.</remarks>
        /// <returns>
        ///     Количество принятых сообщений или код ошибки (см. таблицу ниже)
        ///     <list type="table">
        ///         <item>
        ///             <term>N >= 0</term>
        ///             <description>Количество принятых сообщений (не больше BagsNumber).</description>
        ///         </item>
        ///         <item>
        ///             <term>-1</term>
        ///             <description>Сокет закрыт</description>
        ///         </item>
        ///         <item>
        ///             <term>-255</term>
        ///             <description>Неизвестная ошибка</description>
        ///         </item>
        ///     </list>
        /// </returns>
        [DllImport(SocketCanLibraryName, CallingConvention = CallingConvention.Cdecl)]
        private static extern int SocketRead(int Number, FrameBag* Bags, uint BagsCount, int Timeout);

        #endregion

        #region Оборачивание библиотечных функций

        public const int ReceiveBufferLength = 16;
        private static readonly Encoder Encoder = Encoding.ASCII.GetEncoder();

        private static byte[] GetCString(String str)
        {
            var cString = new byte[str.Length + 1];
            Encoder.GetBytes(str.ToCharArray(), 0, str.Length, cString, 0, true);
            cString[cString.Length - 1] = (byte)char.MinValue;
            return cString;
        }

        private static CanFrame GetCanFrame(FrameBag Bag)
        {
            SocketCanFdFrame scFrame = Bag.Frame;

            var data = new byte[scFrame.DataLength];
            for (int i = 0; i < data.Length; i++) data[i] = scFrame.Data[i];
            CanFrame res = CanFrame.NewWithId((int)scFrame.Id, data);
            res.Time = Bag.ReceiveTime;
            res.IsLoopback = Bag.Flags.HasFlag(FrameBagFlags.Loopback);
            return res;
        }

        /// <summary>Открывает сокет.</summary>
        /// <param name="InterfaceName">Имя сокета в виде c-строки.</param>
        /// <exception cref="SocketCanOpenException">Ошибка при попытке открыть сокет.</exception>
        public static int Open(String InterfaceName)
        {
            int number = SocketOpen(GetCString(InterfaceName));
            if (number <= 0) throw new SocketCanOpenException(-number);
            return number;
        }

        /// <summary>Закрывает сокет.</summary>
        /// <param name="Number">Номер сокета.</param>
        public static void Close(int Number) { SocketClose(Number); }

        /// <summary>Отправляет CAN-фрейм.</summary>
        /// <param name="SocketNumber">Номер сокета для отправки.</param>
        /// <param name="Frame">Фрейм для отправки.</param>
        public static void Write(int SocketNumber, CanFrame Frame)
        {
            var scFrame = new SocketCanFdFrame(Frame);
            int writeStatus = SocketWrite(SocketNumber, &scFrame);
            if (writeStatus < 0) throw new SocketCanWriteException(-writeStatus);
        }

        /// <summary>Пытается прочитать фреймы из сокета.</summary>
        /// <param name="SocketNumber">Номер сокета для чтения.</param>
        /// <param name="Timeout">Таймаут ожидания получения сообщения в случае, если во входящем буфере не оказалось сообщений.</param>
        /// <returns>Список фреймов, прочитанных из указанного сокета.</returns>
        public static IList<CanFrame> Read(int SocketNumber, TimeSpan Timeout)
        {
            var bags = new FrameBag[ReceiveBufferLength];
            int result;
            fixed (FrameBag* bagsPtr = bags)
            {
                result = SocketRead(SocketNumber, bagsPtr, ReceiveBufferLength, (int)Timeout.TotalMilliseconds);
            }

            if (result >= 0) return bags.Take(result).Select(GetCanFrame).ToList();
            throw new SocketCanReadException(-result);
        }

        #endregion
    }
}
